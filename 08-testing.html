<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Writing tests - Learn Haskell by building a blog generator</title>
        <!-- Custom HTML head -->
        <script defer data-domain="lhbg-book.link" src="https://analytics.gilmi.dev/js/plausible.js"></script>

        <meta name="twitter:card" content="summary">
        <meta name="twitter:title" content="Learn Haskell by building a blog generator">
        <meta name="twitter:description" content="A project-oriented online book about Haskell">
        <meta name="twitter:site" content="@_gilmi">
        <meta name="twitter:image" content="https://soupi.github.io/learn-haskell-blog-generator/book-logo.png">
        <meta name="twitter:image-alt" content="drawing of a lambda that is also a book">

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="A project-oriented online book about Haskell">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="01-about.html"><strong aria-hidden="true">1.</strong> About this book</a></li><li class="chapter-item expanded "><a href="02-hello.html"><strong aria-hidden="true">2.</strong> Hello world</a></li><li class="chapter-item expanded "><a href="03-html_printer.html"><strong aria-hidden="true">3.</strong> Building an HTML printer library</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="03-html/01-html_content.html"><strong aria-hidden="true">3.1.</strong> Flexible HTML content (functions)</a></li><li class="chapter-item expanded "><a href="03-html/02-type_signatures.html"><strong aria-hidden="true">3.2.</strong> Adding type signatures</a></li><li class="chapter-item expanded "><a href="03-html/03-edsls.html"><strong aria-hidden="true">3.3.</strong> Embedded Domain Specific Languages</a></li><li class="chapter-item expanded "><a href="03-html/04-safer_construction.html"><strong aria-hidden="true">3.4.</strong> Safer HTML construction with types</a></li><li class="chapter-item expanded "><a href="03-html/05-modules.html"><strong aria-hidden="true">3.5.</strong> Preventing incorrect use with modules</a></li><li class="chapter-item expanded "><a href="03-html/06-escaping_characters.html"><strong aria-hidden="true">3.6.</strong> Escaping characters</a></li><li class="chapter-item expanded "><a href="03-html/07-internal_modules.html"><strong aria-hidden="true">3.7.</strong> Exposing internal functionality (Internal modules)</a></li><li class="chapter-item expanded "><a href="03-html/08-exercises.html"><strong aria-hidden="true">3.8.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="03-html/09-summary.html"><strong aria-hidden="true">3.9.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><a href="04-markup.html"><strong aria-hidden="true">4.</strong> Custom markup language</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="04-markup/01-data_type.html"><strong aria-hidden="true">4.1.</strong> Representing the markup language as a Haskell data type</a></li><li class="chapter-item expanded "><a href="04-markup/02-parsing_01.html"><strong aria-hidden="true">4.2.</strong> Parsing markup part 01 (Recursion)</a></li><li class="chapter-item expanded "><a href="04-markup/03-displaying_results.html"><strong aria-hidden="true">4.3.</strong> Displaying the parsing results (type classes)</a></li><li class="chapter-item expanded "><a href="04-markup/04-parsing_02.html"><strong aria-hidden="true">4.4.</strong> Parsing markup part 02 (Pattern matching)</a></li></ol></li><li class="chapter-item expanded "><a href="05-glue.html"><strong aria-hidden="true">5.</strong> Gluing things together</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="05-glue/01-markup_to_html.html"><strong aria-hidden="true">5.1.</strong> Converting Markup to HTML</a></li><li class="chapter-item expanded "><a href="05-glue/02-io.html"><strong aria-hidden="true">5.2.</strong> Working with IO</a></li><li class="chapter-item expanded "><a href="05-glue/03-project.html"><strong aria-hidden="true">5.3.</strong> Defining a project description</a></li><li class="chapter-item expanded "><a href="05-glue/04-optparse.html"><strong aria-hidden="true">5.4.</strong> Fancy options parsing</a></li></ol></li><li class="chapter-item expanded "><a href="06-errors_and_files.html"><strong aria-hidden="true">6.</strong> Handling errors and multiple files</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="06-errors_and_files/01-either.html"><strong aria-hidden="true">6.1.</strong> Handling errors with Either</a></li><li class="chapter-item expanded "><a href="06-errors_and_files/02-except.html"><strong aria-hidden="true">6.2.</strong> Either with IO?</a></li><li class="chapter-item expanded "><a href="06-errors_and_files/03-exceptions.html"><strong aria-hidden="true">6.3.</strong> Exceptions</a></li><li class="chapter-item expanded "><a href="06-errors_and_files/04-implementation.html"><strong aria-hidden="true">6.4.</strong> Let's code already!</a></li><li class="chapter-item expanded "><a href="06-errors_and_files/05-summary.html"><strong aria-hidden="true">6.5.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><a href="07-environment.html"><strong aria-hidden="true">7.</strong> Passing an environment</a></li><li class="chapter-item expanded "><a href="08-testing.html" class="active"><strong aria-hidden="true">8.</strong> Writing tests</a></li><li class="chapter-item expanded "><a href="09-documentation.html"><strong aria-hidden="true">9.</strong> Generating documentation</a></li><li class="chapter-item expanded "><a href="10-recap.html"><strong aria-hidden="true">10.</strong> Recap</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><a href="11-next.html">Where to go next</a></li><li class="chapter-item expanded affix "><a href="12-faq.html">Frequently asked questions</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Learn Haskell by building a blog generator</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/soupi/learn-haskell-blog-generator" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="testing"><a class="header" href="#testing">Testing</a></h1>
<p>We want to add some tests to our blog generator. At the very least
a few regression tests to make sure that if we extend or change our markup parsing code,
HTML generation code, or translation from markup to HTML code, and make a mistake, we'll
have a safety net alerting us of issues.</p>
<p>We will use the <a href="https://hspec.github.io/">Hspec</a> testing framework to write our tests.
There are other testing frameworks in Haskell, for example,
<a href="https://hackage.haskell.org/package/tasty">tasty</a>, but I like Hspec's documentation,
so we'll use that.</p>
<h2 id="initial-setup"><a class="header" href="#initial-setup">Initial setup</a></h2>
<h3 id="cabal-file-additions"><a class="header" href="#cabal-file-additions">Cabal file additions</a></h3>
<p>We're going to define a new section in our <code>hs-blog-gen.cabal</code> file for our new test suite.
This section is called <code>test-suite</code> and is fairly similar to the <code>library</code> and
<code>executable</code> sections.</p>
<p>The interfaces for how to define a test suite are described in the
<a href="https://cabal.readthedocs.io/en/stable/cabal-package.html#test-suites">Cabal documentation</a>.
We are going to use the <code>exitcode-stdio-1.0</code> interface. Let's go over the different settings
and options:</p>
<pre><code class="language-cabal">test-suite hs-blog-gen-test
  import: common-settings
  type: exitcode-stdio-1.0
  hs-source-dirs: test
  main-is: Spec.hs

  -- other-modules:
  build-depends:
      base
    , hspec
    , hspec-discover
    , raw-strings-qq
    , hs-blog
  ghc-options:
    -O -threaded -rtsopts -with-rtsopts=-N
  build-tool-depends:
    hspec-discover:hspec-discover
</code></pre>
<ul>
<li><code>hs-source-dirs: test</code> - The directory of the source files for the test suite</li>
<li><code>main-is: Spec.hs</code> - The entry point to the test suite</li>
<li><code>other-modules</code> - The modules in our test suite.
Currently commented out because we haven't added any yet</li>
<li><code>build-depends</code> - The packages we are going to use:
<ul>
<li><a href="https://hackage.haskell.org/package/base"><code>base</code></a> -
The standard library for Haskell, as we've used before</li>
<li><a href="https://hackage.haskell.org/package/hspec"><code>hspec</code></a> -
The test framework we are going to use</li>
<li><a href="https://hackage.haskell.org/package/hspec-discover"><code>hspec-discover</code></a> -
Automatic discovery of Hspec tests</li>
<li><a href="https://hackage.haskell.org/package/raw-strings-qq"><code>raw-strings-qq</code></a> -
Additional syntax for writing raw string literals</li>
<li><code>hs-blog</code> - Our library</li>
</ul>
</li>
<li><a href="https://cabal.readthedocs.io/en/stable/cabal-package.html#pkg-field-ghc-options"><code>ghc-options</code></a> -
Extra options and flags for GHC:
<ul>
<li><a href="https://downloads.haskell.org/ghc/latest/docs/html/users_guide/using-optimisation.html#options-optimise"><code>-O</code></a> -
Compile with optimizations</li>
<li><a href="https://downloads.haskell.org/ghc/latest/docs/html/users_guide/phases.html#ghc-flag--threaded"><code>-threaded</code></a> -
Use the multi-core runtime instead of the single-core runtime. The multi-core
runtime is generally a bit slower in my experience, but when writing code that actually uses
multiple cores (such as a test framework that runs tests in parallel), it can give a good
performance boost</li>
<li><a href="https://downloads.haskell.org/ghc/latest/docs/html/users_guide/phases.html#ghc-flag--rtsopts%5B=%E2%9F%A8none%7Csome%7Call%7Cignore%7CignoreAll%E2%9F%A9%5D"><code>-rtsopts</code></a> -
Let us configure the Haskell runtime system by passing command-line arguments to our application</li>
<li><a href="https://downloads.haskell.org/ghc/latest/docs/html/users_guide/phases.html#ghc-flag--with-rtsopts=%E2%9F%A8opts%E2%9F%A9"><code>-with-rtsopts=-N</code></a> -
Set specific default options for the program at link-time.
Specifically, <a href="https://downloads.haskell.org/ghc/latest/docs/html/users_guide/using-concurrent.html#rts-flag--N%20%E2%9F%A8x%E2%9F%A9"><code>-N</code></a>
Sets the number of cores to use in our program</li>
</ul>
</li>
<li><a href="https://cabal.readthedocs.io/en/stable/cabal-package.html#pkg-field-build-tool-depends"><code>build-tool-depends</code></a> -
Use a specific executable from a package dependency in aid of building the package.
In this case, we are using the <code>hspec-discover</code> executable from the
<a href="https://hackage.haskell.org/package/hspec-discover"><code>hspec-discover</code></a> package, which
goes over the source directory for the tests, finds all of the <code>Spec</code> files
and creates an entry point for the program that will run all the tests it discovered</li>
</ul>
<h3 id="hspec-discovery"><a class="header" href="#hspec-discovery">Hspec discovery</a></h3>
<p>For <code>hspec-discover</code> to work, we need to add the following
to the &quot;main&quot; file of the test suite, for us, this is <code>test/Spec.hs</code>:</p>
<pre><code class="language-hs">{-# OPTIONS_GHC -F -pgmF hspec-discover #-}
</code></pre>
<p>That's it! <code>hspec-discover</code> will automatically define a <code>main</code> for us.
Now we can run the tests using <code>stack test</code> or <code>cabal test</code> (your choice).
Because we haven't defined any tests, our output is:</p>
<pre><code class="language-sh">Finished in 0.0000 seconds
0 examples, 0 failures
</code></pre>
<p>When we add new Hspec tests, <code>hspec-discover</code> will find and run them automatically
(though we will still need to add them to the <code>other-modules</code> section in the cabal file).</p>
<p>For <code>hspec-discover</code> to identify modules as test modules, the modules must follow
a convention:</p>
<ol>
<li>Their module names must end with <code>Spec</code></li>
<li>They must define a value <code>spec :: Spec</code> (which describes the test) and export it
outside of the module (by adding it to the export list of the module, for example)</li>
</ol>
<h2 id="writing-tests"><a class="header" href="#writing-tests">Writing tests</a></h2>
<p>Let's write our first test. We'll create a new module to test
markup parsing. We'll call it <code>MarkupParsingSpec.hs</code>. We'll need
the following imports as well:</p>
<pre><code class="language-hs">module MarkupParsingSpec where

import Test.Hspec
import HsBlog.Markup
</code></pre>
<p><code>Hspec</code> provides us with a monadic interface for describing, composing and
nesting test specifications (<code>Spec</code>s).</p>
<p>Using the <code>describe</code> function, we can
describe a group of tests; using the <code>it</code> function, we can add a new test,
and using a function like <code>shouldBe</code>, we can compare two values and make
sure they are equal by using their <code>Eq</code> instance.
If they are, the test will pass; if not, it will fail with a descriptive error.</p>
<p>Let's try it and write a test that obviously fails!</p>
<pre><code class="language-hs">spec :: Spec
spec = do
  describe &quot;Markup parsing tests&quot; $ do
    it &quot;empty&quot; $
      shouldBe
        (parse &quot;&quot;)
        [Heading 1 &quot;bug&quot;]
</code></pre>
<p>After adding the module to the <code>other-modules</code> list in the cabal file:</p>
<pre><code class="language-hs">  other-modules:
    MarkupParsingSpec
</code></pre>
<p>And running the tests, we get this output:</p>
<pre><code class="language-hs">MarkupParsing
  Markup parsing tests
    empty FAILED [1]

Failures:

  test/MarkupParsingSpec.hs:10:7:
  1) MarkupParsing, Markup parsing tests, empty
       expected: [Heading 1 &quot;bug&quot;]
        but got: []

  To rerun use: --match &quot;/MarkupParsing/Markup parsing tests/empty/&quot;

Randomized with seed 763489823

Finished in 0.0004 seconds
1 example, 1 failure
</code></pre>
<p>The output describes which tests are running in a hierarchy tree (module, group, and test),
whether the tests pass or fail, and if they fail, the output and the expected output.</p>
<p>We can fix our test by matching the expected output:</p>
<pre><code class="language-hs">      shouldBe
        (parse &quot;&quot;)
        []
</code></pre>
<p>Now, running the tests will produce:</p>
<pre><code class="language-hs">MarkupParsing
  Markup parsing tests
    empty

Finished in 0.0001 seconds
1 example, 0 failures
</code></pre>
<p>We can add a few more tests:</p>
<pre><code class="language-hs">    it &quot;paragraph&quot; $
      shouldBe
        (parse &quot;hello world&quot;)
        [Paragraph &quot;hello world&quot;]

    it &quot;heading 1&quot; $
      shouldBe
        (parse &quot;* Heading 1&quot;)
        [Heading 1 &quot;Heading 1&quot;]

    it &quot;code&quot; $
      shouldBe
        (parse &quot;&gt; main = putStrLn \&quot;hello world!\&quot;&quot;)
        [CodeBlock [&quot;main = putStrLn \&quot;hello world!\&quot;&quot;]]
</code></pre>
<p>And run the tests again:</p>
<pre><code class="language-sh">MarkupParsing
  Markup parsing tests
    Test empty
    paragraph
    heading 1
    code

Finished in 0.0003 seconds
4 examples, 0 failures
</code></pre>
<p>This is the gist of writing unit tests with Hspec. It's important to note
that we can nest <code>Spec</code>s that are declared with <code>describe</code> to create trees,
and, of course, refactor and move things to different functions and modules
to make our test suite better organized.</p>
<p>For example, we can write our tests like this:</p>
<pre><code class="language-hs">spec :: Spec
spec = do
  describe &quot;Markup parsing tests&quot; $ do
    simple

simple :: Spec
simple = do
  describe &quot;simple&quot; $ do
    it &quot;empty&quot; $
      shouldBe
        (parse &quot;&quot;)
        []

    it &quot;paragraph&quot; $
      shouldBe
        (parse &quot;hello world&quot;)
        [Paragraph &quot;hello world&quot;]

    it &quot;heading 1&quot; $
      shouldBe
        (parse &quot;* Heading 1&quot;)
        [Heading 1 &quot;Heading 1&quot;]

    it &quot;code&quot; $
      shouldBe
        (parse &quot;&gt; main = putStrLn \&quot;hello world!\&quot;&quot;)
        [CodeBlock [&quot;main = putStrLn \&quot;hello world!\&quot;&quot;]]
</code></pre>
<p>Also, there are other &quot;expectations&quot; like <code>shouldBe</code> that we can use when writing tests.
They are described in the <a href="https://hspec.github.io/expectations.html">Hspec tutorial</a>
and can be found in the
<a href="https://hackage.haskell.org/package/hspec-expectations-0.8.2/docs/Test-Hspec-Expectations.html">haddock documentation</a> as well.</p>
<h3 id="raw-strings"><a class="header" href="#raw-strings">Raw strings</a></h3>
<p>If we want to write multi-line strings or avoid escaping strings as we did in the &quot;code&quot;
test, we can use a library called
<a href="https://hackage.haskell.org/package/raw-strings-qq">raw-strings-qq</a>
which uses a language extension called
<a href="https://downloads.haskell.org/ghc/latest/docs/html/users_guide/exts/template_haskell.html#extension-QuasiQuotes"><code>QuasiQuotes</code></a>.
<code>QuasiQuotes</code> is a meta-programming extension that provides a mechanism for extending the
syntax of Haskell.</p>
<p>A quasi-quote has the form <code>[quoter| string |]</code>, where the quoter is the name
of the function providing the syntax we wish to use, and the string is our input.</p>
<p>In our case, we use the quoter <code>r</code>, which is defined in
<a href="https://hackage.haskell.org/package/raw-strings-qq-1.1/docs/Text-RawString-QQ.html">raw-strings-qq</a>,
and write any string we want, with multi-lines and unescaped characters!
We could use this to write the tests
<a href="04-markup/01-data_type.html#exercises">we previously wrote</a>:</p>
<pre><code class="language-hs">{-# language QuasiQuotes #-}

...

import Text.RawString.QQ

...

example3 :: String
example3 = [r|
Remember that multiple lines with no separation
are grouped together to a single paragraph
but list items remain separate.

# Item 1 of a list
# Item 2 of the same list
|]
</code></pre>
<p>And add multi-line tests:</p>
<pre><code class="language-hs">spec :: Spec
spec = do
  describe &quot;Markup parsing tests&quot; $ do
    simple
    multiline


multiline :: Spec
multiline = do
  describe &quot;Multi-line tests&quot; $ do
    it &quot;example3&quot; $
      shouldBe
        (parse example3)
        example3Result


example3 :: String
example3 = [r|
Remember that multiple lines with no separation
are grouped together to a single paragraph
but list items remain separate.

# Item 1 of a list
# Item 2 of the same list
|]

example3Result :: Document
example3Result =
  [ Paragraph &quot;Remember that multiple lines with no separation are grouped together to a single paragraph but list items remain separate.&quot;
  , OrderedList
    [ &quot;Item 1 of a list&quot;
    , &quot;Item 2 of the same list&quot;
    ]
  ]
</code></pre>
<p>Running the tests:</p>
<pre><code class="language-hs">MarkupParsing
  Markup parsing tests
    simple
      Test empty
      paragraph
      heading 1
      code
    Multi-line tests
      example3

Finished in 0.0004 seconds
5 examples, 0 failures
</code></pre>
<hr />
<p><strong>Exercise</strong>: Add a test for the fourth example described in the
<a href="04-markup/01-data_type.html#exercises">previous exercises</a>.</p>
<details><summary>Solution</summary>
<pre><code class="language-hs">multiline :: Spec
multiline = do
  describe &quot;Multi-line tests&quot; $ do
    it &quot;example3&quot; $
      shouldBe
        (parse example3)
        example3Result

    it &quot;example4&quot; $
      shouldBe
        (parse example4)
        example4Result


example4 :: String
example4 = [r|
* Compiling programs with ghc

Running ghc invokes the Glasgow Haskell Compiler (GHC),
and can be used to compile Haskell modules and programs into native
executables and libraries.

Create a new Haskell source file named hello.hs, and write
the following code in it:

&gt; main = putStrLn &quot;Hello, Haskell!&quot;

Now, we can compile the program by invoking ghc with the file name:

&gt; ➜ ghc hello.hs
&gt; [1 of 1] Compiling Main             ( hello.hs, hello.o )
&gt; Linking hello ...

GHC created the following files:

- hello.hi - Haskell interface file
- hello.o - Object file, the output of the compiler before linking
- hello (or hello.exe on Microsoft Windows) - A native runnable executable.

GHC will produce an executable when the source file satisfies both conditions:

# Defines the main function in the source file
# Defines the module name to be Main, or does not have a module declaration

Otherwise, it will only produce the .o and .hi files.
|]

example4Result :: Document
example4Result =
  [ Heading 1 &quot;Compiling programs with ghc&quot;
  , Paragraph &quot;Running ghc invokes the Glasgow Haskell Compiler (GHC), and can be used to compile Haskell modules and programs into native executables and libraries.&quot;
  , Paragraph &quot;Create a new Haskell source file named hello.hs, and write the following code in it:&quot;
  , CodeBlock
    [ &quot;main = putStrLn \&quot;Hello, Haskell!\&quot;&quot;
    ]
  , Paragraph &quot;Now, we can compile the program by invoking ghc with the file name:&quot;
  , CodeBlock
    [ &quot;➜ ghc hello.hs&quot;
    , &quot;[1 of 1] Compiling Main             ( hello.hs, hello.o )&quot;
    , &quot;Linking hello ...&quot;
    ]
  , Paragraph &quot;GHC created the following files:&quot;
  , UnorderedList
    [ &quot;hello.hi - Haskell interface file&quot;
    , &quot;hello.o - Object file, the output of the compiler before linking&quot;
    , &quot;hello (or hello.exe on Microsoft Windows) - A native runnable executable.&quot;
    ]
  , Paragraph &quot;GHC will produce an executable when the source file satisfies both conditions:&quot;
  , OrderedList
    [ &quot;Defines the main function in the source file&quot;
    , &quot;Defines the module name to be Main, or does not have a module declaration&quot;
    ]
  , Paragraph &quot;Otherwise, it will only produce the .o and .hi files.&quot;
  ]
</code></pre>
</details>
<hr />
<h2 id="parallel-test-execution"><a class="header" href="#parallel-test-execution">Parallel test execution</a></h2>
<p>Without further configuration, Hspec will run all
of our tests on the main thread sequentially.</p>
<p>There are a couple of ways to configure tests to run
in parallel. One is to manually mark a <code>Spec</code>
as parallel by passing it to the <code>parallel</code> function,
and another is by creating a /hook/ that will apply
<code>parallel</code> to each <code>Spec</code> automatically with
<code>hspec-discover</code>.</p>
<p>Consult the <a href="https://hspec.github.io/parallel-spec-execution.html#running-all-tests-in-parallel-with-hspec-discover">Hspec manual</a>
on this topic and try both methods. Remember that
we already enabled the threaded runtime and set it to
use multiple cores in the cabal file.</p>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>This chapter has been just the tip of the iceberg of the Haskell testing landscape.
We haven't talked about
<a href="https://www.scs.stanford.edu/16wi-cs240h/slides/testing.html">property testing</a> or
<a href="https://ro-che.info/articles/2017-12-04-golden-tests">golden testing</a>,
testing expected failures, testing IO code, inspection testing, benchmarking, and more.
There's just too much to cover!</p>
<p>I hope this chapter
provided you with the basics of how to start writing tests for your projects.
Please consult the tutorial for your chosen testing framework, and read more about
this very important subject on your own.</p>
<blockquote>
<p>You can view the git commit of
<a href="https://github.com/soupi/learn-haskell-blog-generator/commit/da1615b6e0a2a4ff2728528240d790754853bf02">the changes we've made</a>
and the <a href="https://github.com/soupi/learn-haskell-blog-generator/tree/da1615b6e0a2a4ff2728528240d790754853bf02">code up until now</a>.</p>
</blockquote>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="07-environment.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="09-documentation.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="07-environment.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="09-documentation.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script>
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" charset="utf-8"></script>
        <script src="mark.min.js" charset="utf-8"></script>
        <script src="searcher.js" charset="utf-8"></script>
        <script src="clipboard.min.js" charset="utf-8"></script>
        <script src="highlight.js" charset="utf-8"></script>
        <script src="book.js" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
