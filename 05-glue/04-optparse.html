<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Fancy options parsing - Learn Haskell by building a blog generator</title>
        <!-- Custom HTML head -->
        <script defer data-domain="lhbg-book.link" src="https://analytics.gilmi.dev/js/plausible.js"></script>

        <meta name="twitter:card" content="summary">
        <meta name="twitter:title" content="Learn Haskell by building a blog generator">
        <meta name="twitter:description" content="A project-oriented online book about Haskell">
        <meta name="twitter:site" content="@_gilmi">
        <meta name="twitter:image" content="https://soupi.github.io/learn-haskell-blog-generator/book-logo.png">
        <meta name="twitter:image-alt" content="drawing of a lambda that is also a book">

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="A project-oriented online book about Haskell">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../01-about.html"><strong aria-hidden="true">1.</strong> About this book</a></li><li class="chapter-item expanded "><a href="../02-hello.html"><strong aria-hidden="true">2.</strong> Hello world</a></li><li class="chapter-item expanded "><a href="../03-html_printer.html"><strong aria-hidden="true">3.</strong> Building an HTML printer library</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../03-html/01-html_content.html"><strong aria-hidden="true">3.1.</strong> Flexible HTML content (functions)</a></li><li class="chapter-item expanded "><a href="../03-html/02-type_signatures.html"><strong aria-hidden="true">3.2.</strong> Adding type signatures</a></li><li class="chapter-item expanded "><a href="../03-html/03-edsls.html"><strong aria-hidden="true">3.3.</strong> Embedded Domain Specific Languages</a></li><li class="chapter-item expanded "><a href="../03-html/04-safer_construction.html"><strong aria-hidden="true">3.4.</strong> Safer HTML construction with types</a></li><li class="chapter-item expanded "><a href="../03-html/05-modules.html"><strong aria-hidden="true">3.5.</strong> Preventing incorrect use with modules</a></li><li class="chapter-item expanded "><a href="../03-html/06-escaping_characters.html"><strong aria-hidden="true">3.6.</strong> Escaping characters</a></li><li class="chapter-item expanded "><a href="../03-html/07-internal_modules.html"><strong aria-hidden="true">3.7.</strong> Exposing internal functionality (Internal modules)</a></li><li class="chapter-item expanded "><a href="../03-html/08-exercises.html"><strong aria-hidden="true">3.8.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="../03-html/09-summary.html"><strong aria-hidden="true">3.9.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><a href="../04-markup.html"><strong aria-hidden="true">4.</strong> Custom markup language</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../04-markup/01-data_type.html"><strong aria-hidden="true">4.1.</strong> Representing the markup language as a Haskell data type</a></li><li class="chapter-item expanded "><a href="../04-markup/02-parsing_01.html"><strong aria-hidden="true">4.2.</strong> Parsing markup part 01 (Recursion)</a></li><li class="chapter-item expanded "><a href="../04-markup/03-displaying_results.html"><strong aria-hidden="true">4.3.</strong> Displaying the parsing results (type classes)</a></li><li class="chapter-item expanded "><a href="../04-markup/04-parsing_02.html"><strong aria-hidden="true">4.4.</strong> Parsing markup part 02 (Pattern matching)</a></li></ol></li><li class="chapter-item expanded "><a href="../05-glue.html"><strong aria-hidden="true">5.</strong> Gluing things together</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../05-glue/01-markup_to_html.html"><strong aria-hidden="true">5.1.</strong> Converting Markup to HTML</a></li><li class="chapter-item expanded "><a href="../05-glue/02-io.html"><strong aria-hidden="true">5.2.</strong> Working with IO</a></li><li class="chapter-item expanded "><a href="../05-glue/03-project.html"><strong aria-hidden="true">5.3.</strong> Defining a project description</a></li><li class="chapter-item expanded "><a href="../05-glue/04-optparse.html" class="active"><strong aria-hidden="true">5.4.</strong> Fancy options parsing</a></li></ol></li><li class="chapter-item expanded "><a href="../06-errors_and_files.html"><strong aria-hidden="true">6.</strong> Handling errors and multiple files</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../06-errors_and_files/01-either.html"><strong aria-hidden="true">6.1.</strong> Handling errors with Either</a></li><li class="chapter-item expanded "><a href="../06-errors_and_files/02-except.html"><strong aria-hidden="true">6.2.</strong> Either with IO?</a></li><li class="chapter-item expanded "><a href="../06-errors_and_files/03-exceptions.html"><strong aria-hidden="true">6.3.</strong> Exceptions</a></li><li class="chapter-item expanded "><a href="../06-errors_and_files/04-implementation.html"><strong aria-hidden="true">6.4.</strong> Let's code already!</a></li><li class="chapter-item expanded "><a href="../06-errors_and_files/05-summary.html"><strong aria-hidden="true">6.5.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><a href="../07-environment.html"><strong aria-hidden="true">7.</strong> Passing an environment</a></li><li class="chapter-item expanded "><a href="../08-testing.html"><strong aria-hidden="true">8.</strong> Writing tests</a></li><li class="chapter-item expanded "><a href="../09-documentation.html"><strong aria-hidden="true">9.</strong> Generating documentation</a></li><li class="chapter-item expanded "><a href="../10-recap.html"><strong aria-hidden="true">10.</strong> Recap</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><a href="../11-next.html">Where to go next</a></li><li class="chapter-item expanded affix "><a href="../12-faq.html">Frequently asked questions</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Learn Haskell by building a blog generator</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/soupi/learn-haskell-blog-generator" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="fancy-options-parsing"><a class="header" href="#fancy-options-parsing">Fancy options parsing</a></h1>
<p>We'd like to define a nicer interface for our program. While we could manage something
ourselves with <code>getArgs</code> and pattern matching, it is easier to get good results using a library.
We are going to use a package called
<a href="https://hackage.haskell.org/package/optparse-applicative">optparse-applicative</a>.</p>
<p><code>optparse-applicative</code> provides us with an EDSL (yes, another one) to build
command arguments parsers. Things like commands, switches, and flags can be built
and composed together to make a parser for command-line arguments without actually
writing operations on strings as we did when we wrote our Markup parser, and will
provide other benefits such as automatic generation of usage lines, help screens,
error reporting, and more.</p>
<p>While <code>optparse-applicative</code>'s dependency footprint isn't very large,
it is likely that a user of our library wouldn't need command-line parsing
in this particular case, so it makes sense to add this dependency to the <code>executable</code> section
(rather than the <code>library</code> section) in the <code>.cabal</code> file:</p>
<pre><code class="language-diff"> executable hs-blog-gen
   import: common-settings
   hs-source-dirs: app
   main-is: Main.hs
   build-depends:
       base
+    , optparse-applicative
     , hs-blog
   ghc-options:
     -O
</code></pre>
<h2 id="building-a-command-line-parser"><a class="header" href="#building-a-command-line-parser">Building a command-line parser</a></h2>
<p>The optparse-applicative package has pretty decent
<a href="https://hackage.haskell.org/package/optparse-applicative-0.16.1.0#optparse-applicative">documentation</a>,
but we will cover a few important things to pay attention to in this chapter.</p>
<p>In general, there are four important things we need to do:</p>
<ol>
<li>
<p>Define our model - we want to define an ADT that describes the various options
and commands for our program</p>
</li>
<li>
<p>Define a parser that will produce a value of our model type when run</p>
</li>
<li>
<p>Run the parser on our program arguments input</p>
</li>
<li>
<p>Pattern match on the model and call the right operations according to the options</p>
</li>
</ol>
<h3 id="define-a-model"><a class="header" href="#define-a-model">Define a model</a></h3>
<p>Let's envision our command-line interface for a second; what should it
look like?</p>
<p>We want to be able to convert a single file or input stream to either a file
or an output stream, or we want to process a whole directory and create a new directory.
We can model it in an ADT like this:</p>
<pre><code class="language-hs">data Options
  = ConvertSingle SingleInput SingleOutput
  | ConvertDir FilePath FilePath
  deriving Show

data SingleInput
  = Stdin
  | InputFile FilePath
  deriving Show

data SingleOutput
  = Stdout
  | OutputFile FilePath
  deriving Show
</code></pre>
<blockquote>
<p>Note that we could technically also use <code>Maybe FilePath</code> to encode both <code>SingleInput</code>
and <code>SingleOutput</code>, but then we would have to remember what <code>Nothing</code> means
in each context. By creating a new type with properly named constructors
for each option, we make it easier for readers of the code to understand
the meaning of our code.</p>
</blockquote>
<p>In terms of interface, we could decide that when a user would like to convert
a single input source, they would use the <code>convert</code> command, and supply the optional flags
<code>--input FILEPATH</code> and <code>--output FILEPATH</code> to read or write from a file.
When the user does not supply one or both flags, we will read or write from
the standard input/output accordingly.</p>
<p>If the user would like to convert a directory, they can use the <code>convert-dir</code>
command and supply the two mandatory flags <code>--input FILEPATH</code> and
<code>--output FILEPATH</code>.</p>
<h3 id="build-a-parser"><a class="header" href="#build-a-parser">Build a parser</a></h3>
<p>This is the most interesting part of the process. How do we build a parser
that fits our model?</p>
<p>The <code>optparse-applicative</code> library introduces a new type called <code>Parser</code>.
<code>Parser</code>, similar to <code>Maybe</code> and <code>IO</code>, has the kind <code>* -&gt; *</code> - when it
is supplied with a saturated (or concrete) type such as <code>Int</code>, <code>Bool</code> or
<code>Options</code>, it can become a saturated type (one that has values).</p>
<p>A <code>Parser a</code> represents a specification of a command-line options parser
that produces a value of type <code>a</code> when the command-line arguments are
successfully parsed.
This is similar to how <code>IO a</code> represents a description of a program
that can produce a value of type <code>a</code>. The main difference between these
two types is that while we can't convert an <code>IO a</code> to an <code>a</code>
(we just chain IO operations and have the Haskell runtime execute them),
we <em>can</em> convert a <code>Parser a</code> to a function that takes a list of strings
representing the program arguments and produces an <code>a</code> if it manages
to parse the arguments.</p>
<p>As we've seen with the previous EDSLs, this library uses the <em>combinator pattern</em>
as well. We need to consider the basic primitives for building
a parser and the methods of composing small parsers into bigger
parsers.</p>
<p>Let's see an example of a small parser:</p>
<pre><code class="language-hs">inp :: Parser FilePath
inp =
  strOption
    ( long &quot;input&quot;
      &lt;&gt; short 'i'
      &lt;&gt; metavar &quot;FILE&quot;
      &lt;&gt; help &quot;Input file&quot;
    )

out :: Parser FilePath
out =
  strOption
    ( long &quot;output&quot;
      &lt;&gt; short 'o'
      &lt;&gt; metavar &quot;FILE&quot;
      &lt;&gt; help &quot;Output file&quot;
    )
</code></pre>
<p><code>strOption</code> is a parser builder. It is a function that takes a combined
<em>option modifiers</em> as an argument, and returns a parser that will parse a string.
We can specify the type to be <code>FilePath</code> because <code>FilePath</code> is an
alias to <code>String</code>. The parser builder describes how to parse the value,
and the modifiers describe its properties, such as the flag name,
the shorthand of the flag name, and how it would be described in the usage
and help messages.</p>
<blockquote>
<p>Actually, <code>strOption</code> can return any string type
that implements the interface <code>IsString</code>. There are a few such types,
for example, <code>Text</code>, a much more efficient Unicode text type from the <code>text</code> package.
It is more efficient than <code>String</code> because while <code>String</code> is implemented as a
linked list of <code>Char</code>, <code>Text</code> is implemented as an array of bytes.
<code>Text</code> is usually what we should use for text values instead of <code>String</code>. We haven't
been using it up until now because it is slightly less ergonomic to use
than <code>String</code>. But it is often the preferred type to use for text!</p>
</blockquote>
<p>As you can see, modifiers can be composed using the <code>&lt;&gt;</code> function,
which means modifiers implement an instance of the <code>Semigroup</code> type class!</p>
<p>With such an interface, we don't have to supply all the modifier
options, only the relevant ones. So if we don't want to
have a shortened flag name, we don't have to add it.</p>
<h4 id="functor"><a class="header" href="#functor">Functor</a></h4>
<p>For the data type we've defined, having <code>Parser FilePath</code> takes us
a good step in the right direction, but it is not exactly what we need
for a <code>ConvertSingle</code>. We need a <code>Parser SingleInput</code> and a
<code>Parser SingleOutput</code>. If we had a <code>FilePath</code>, we could convert
it into <code>SingleInput</code> by using the <code>InputFile</code> constructor.
Remember, <code>InputFile</code> is also a function:</p>
<pre><code class="language-hs">InputFile :: FilePath -&gt; SingleInput
OutputFile :: FilePath -&gt; SingleOutput
</code></pre>
<p>However, to convert a parser, we need functions with these types:</p>
<pre><code class="language-hs">f :: Parser FilePath -&gt; Parser SingleInput
g :: Parser FilePath -&gt; Parser SingleOutput
</code></pre>
<p>Fortunately, the <code>Parser</code> interface provides us with a function to &quot;lift&quot;
a function like <code>FilePath -&gt; SingleInput</code> to work on parsers, making
it a function with the type <code>Parser FilePath -&gt; Parser SingleInput</code>.
Of course, this function will work for any input and output,
so if we have a function with the type <code>a -&gt; b</code>, we can pass it to
that function and get a new function of the type <code>Parser a -&gt; Parser b</code>.</p>
<p>This function is called <code>fmap</code>:</p>
<pre><code class="language-hs">fmap :: (a -&gt; b) -&gt; Parser a -&gt; Parser b

-- Or with its infix version
(&lt;$&gt;)  :: (a -&gt; b) -&gt; Parser a -&gt; Parser b
</code></pre>
<p>We've seen <code>fmap</code> before in the interface of other types:</p>
<pre><code class="language-hs">fmap :: (a -&gt; b) -&gt; [a] -&gt; [b]

fmap :: (a -&gt; b) -&gt; IO a -&gt; IO b
</code></pre>
<p><code>fmap</code> is a type class function like <code>&lt;&gt;</code> and <code>show</code>. It belongs
to the type class <a href="https://hackage.haskell.org/package/base-4.16.4.0/docs/Data-Functor.html#t:Functor"><code>Functor</code></a>:</p>
<pre><code class="language-hs">class Functor f where
  fmap :: (a -&gt; b) -&gt; f a -&gt; f b
</code></pre>
<p>And it has the following laws:</p>
<pre><code class="language-hs">-- 1. Identity law:
--    if we don't change the values, nothing should change
fmap id = id

-- 2. Composition law:
--    Composing the lifted functions is the same a composing
--    them after fmap
fmap (f . g) == fmap f . fmap g
</code></pre>
<p>Any type <code>f</code> that can implement <code>fmap</code> and follow these laws can be a valid
instance of <code>Functor</code>.</p>
<blockquote>
<p>Notice how <code>f</code> has a kind <code>* -&gt; *</code>, we can infer the kind of <code>f</code>
by looking at the other types in the type signature of <code>fmap</code>:</p>
<ol>
<li><code>a</code> and <code>b</code> have the kind <code>*</code> because they are used as arguments/return
types of functions</li>
<li><code>f a</code> has the kind <code>*</code> because it is used as an argument to a function, therefore</li>
<li><code>f</code> has the kind <code>* -&gt; *</code></li>
</ol>
</blockquote>
<p>Let's choose a data type and see if we can implement a <code>Functor</code> instance.
We need to choose a data type that has the kind <code>* -&gt; *</code>. <code>Maybe</code> fits the bill.
We need to implement a function <code>fmap :: (a -&gt; b) -&gt; Maybe a -&gt; Maybe b</code>.
Here's one very simple (and wrong) implementation:</p>
<pre><code class="language-hs">mapMaybe :: (a -&gt; b) -&gt; Maybe a -&gt; Maybe b
mapMaybe func maybeX = Nothing
</code></pre>
<p>Check it out yourself! It compiles successfully! But unfortunately, it does not
satisfy the first law. <code>fmap id = id</code> means that
<code>mapMaybe id (Just x) == Just x</code>, however, from the definition, we can
clearly see that <code>mapMaybe id (Just x) == Nothing</code>.</p>
<p>This is a good example of how Haskell doesn't help us ensure the laws
are satisfied, and why they are important. Unlawful <code>Functor</code> instances
will behave differently from how we'd expect a <code>Functor</code> to behave.
Let's try again!</p>
<pre><code class="language-hs">mapMaybe :: (a -&gt; b) -&gt; Maybe a -&gt; Maybe b
mapMaybe func maybeX =
  case maybeX of
    Nothing -&gt; Nothing
    Just x -&gt; Just (func x)
</code></pre>
<p>This <code>mapMaybe</code> will satisfy the functor laws. This can be proved
by doing algebra - if we can do substitution and reach the other side of the
equation in each law, then the law holds.</p>
<p>Functor is a very important type class, and many types implement this interface.
As we know, <code>IO</code>, <code>Maybe</code>, <code>[]</code> and <code>Parser</code> all have the kind <code>* -&gt; *</code>,
and all allow us to map over their &quot;payload&quot; type.</p>
<blockquote>
<p>Often, people try to look for analogies and metaphors to what a type class means,
but type classes with funny names like <code>Functor</code> don't usually have an
analogy or a metaphor that fits them in all cases. It is easier to give up
on the metaphor and think about it as it is - an interface with laws.</p>
</blockquote>
<p>We can use <code>fmap</code> on <code>Parser</code> to make a parser that returns <code>FilePath</code> to
return a <code>SingleInput</code> or <code>SingleOutput</code> instead:</p>
<pre><code class="language-hs">pInputFile :: Parser SingleInput
pInputFile = fmap InputFile parser
  where
    parser =
      strOption
        ( long &quot;input&quot;
          &lt;&gt; short 'i'
          &lt;&gt; metavar &quot;FILE&quot;
          &lt;&gt; help &quot;Input file&quot;
        )

pOutputFile :: Parser SingleOutput
pOutputFile = OutputFile &lt;$&gt; parser -- fmap and &lt;$&gt; are the same
  where
    parser =
      strOption
        ( long &quot;output&quot;
          &lt;&gt; short 'o'
          &lt;&gt; metavar &quot;FILE&quot;
          &lt;&gt; help &quot;Output file&quot;
        )
</code></pre>
<h4 id="applicative"><a class="header" href="#applicative">Applicative</a></h4>
<p>Now that we have two parsers,
<code>pInputFile :: Parser SingleInput</code>
and <code>pOutputFile :: Parser SingleOutput</code>,
we want to <em>combine</em> them as <code>Options</code>. Again, if we only had
<code>SingleInput</code> and <code>SingleOutput</code>, we could use the constructor <code>ConvertSingle</code>:</p>
<pre><code class="language-hs">ConvertSingle :: SingleInput -&gt; SingleOutput -&gt; Options
</code></pre>
<p>Can we do a similar trick to the one we saw before with <code>fmap</code>?
Does a function exist that can lift a binary function to work
on <code>Parser</code>s instead? One with this type signature:</p>
<pre><code>???
  :: (SingleInput -&gt; SingleOutput -&gt; Options)
  -&gt; (Parser SingleInput -&gt; Parser SingleOutput -&gt; Parser Options)
</code></pre>
<p>Yes. This function is called <code>liftA2</code>, and it is from the <code>Applicative</code>
type class. <code>Applicative</code> (also known as applicative functor) has three
primary functions:</p>
<pre><code class="language-hs">class Functor f =&gt; Applicative f where
  pure :: a -&gt; f a
  liftA2 :: (a -&gt; b -&gt; c) -&gt; f a -&gt; f b -&gt; f c
  (&lt;*&gt;) :: f (a -&gt; b) -&gt; f a -&gt; f b
</code></pre>
<p><a href="https://hackage.haskell.org/package/base-4.16.4.0/docs/Control-Applicative.html#t:Applicative"><code>Applicative</code></a>
is another very popular type class with many instances.</p>
<p>Just like any <code>Monoid</code> is a <code>Semigroup</code>, any <code>Applicative</code>
is a <code>Functor</code>. This means that any type that wants to implement
the <code>Applicative</code> interface should also implement the <code>Functor</code> interface.</p>
<p>Beyond what a regular functor can do, which is to lift a function over
a certain <code>f</code>, applicative functors allow us to apply a function to
<em>multiple instances</em> of a certain <code>f</code>, as well as &quot;lift&quot; any value of type <code>a</code> into an <code>f a</code>.</p>
<p>You should already be familiar with <code>pure</code>, we've seen it when we
talked about <code>IO</code>. For <code>IO</code>, <code>pure</code> lets us create an <code>IO</code> action
with a specific return value without doing IO.
With <code>pure</code> for <code>Parser</code>, we can create a <code>Parser</code> that, when run,
will return a specific value as output without doing any parsing.</p>
<p><code>liftA2</code> and <code>&lt;*&gt;</code> are two functions that can be implemented in
terms of one another. <code>&lt;*&gt;</code> is actually the more useful one between
the two. Because when combined with <code>fmap</code> (or rather the infix version <code>&lt;$&gt;</code>),
it can be used to apply a function with many arguments instead of just two.</p>
<p>To combine our two parsers into one, we can use either <code>liftA2</code> or
a combination of <code>&lt;$&gt;</code> and <code>&lt;*&gt;</code>:</p>
<pre><code class="language-hs">-- with liftA2
pConvertSingle :: Parser Options
pConvertSingle =
  liftA2 ConvertSingle pInputFile pOutputFile

-- with &lt;$&gt; and &lt;*&gt;
pConvertSingle :: Parser Options
pConvertSingle =
  ConvertSingle &lt;$&gt; pInputFile &lt;*&gt; pOutputFile
</code></pre>
<p>Note that both <code>&lt;$&gt;</code> and <code>&lt;*&gt;</code> associate to the left,
so we have invisible parenthesis that look like this:</p>
<pre><code class="language-hs">pConvertSingle :: Parser Options
pConvertSingle =
  (ConvertSingle &lt;$&gt; pInputFile) &lt;*&gt; pOutputFile
</code></pre>
<p>Let's take a deeper look at the types of the sub-expressions
we have here to prove that this type-checks:</p>
<pre><code class="language-hs">pConvertSingle :: Parser Options

pInputFile :: Parser SingleInput
pOutputFile :: Parser SingleOutput

ConvertSingle :: SingleInput -&gt; SingleOutput -&gt; Options

(&lt;$&gt;) :: (a -&gt; b) -&gt; Parser a -&gt; Parser b
  -- Specifically, here `a` is `SingleInput`
  -- and `b` is `SingleOutput -&gt; Options`,

ConvertSingle &lt;$&gt; pInputFile :: Parser (SingleOutput -&gt; Options)

(&lt;*&gt;) :: Parser (a -&gt; b) -&gt; Parser a -&gt; Parser b
  -- Specifically, here `a -&gt; b` is `SingleOutput -&gt; Options`
  -- so `a` is `SingleOutput` and `b` is `Options`

-- So we get:
(ConvertSingle &lt;$&gt; pInputFile) &lt;*&gt; pOutputFile :: Parser Options
</code></pre>
<p>With <code>&lt;$&gt;</code> and <code>&lt;*&gt;</code> we can chain as many parsers (or any applicative, really)
as we want. This is because of two things: currying and parametric polymorphism.
Because functions in Haskell take exactly one argument and return exactly one,
any multiple-argument function can be represented as <code>a -&gt; b</code>.</p>
<blockquote>
<p>You can find the laws for the applicative functors in this article called
<a href="https://wiki.haskell.org/Typeclassopedia#Laws_2">Typeclassopedia</a>, which
talks about various useful type classes and their laws.</p>
</blockquote>
<p>Applicative functor is a very important concept and will appear in various
parser interfaces (not just for command-line arguments, but also JSON
parsers and general parsers), I/O, concurrency, non-determinism, and more.
The reason this library is called optparse-applicative is because
it uses the <code>Applicative</code> interface as the main API for
constructing parsers.</p>
<hr />
<p><strong>Exercise</strong>: create a similar interface for the <code>ConvertDir</code> constructor of <code>Options</code>.</p>
<details><summary>Solution</summary>
<pre><code class="language-hs">pInputDir :: Parser FilePath
pInputDir =
  strOption
    ( long &quot;input&quot;
      &lt;&gt; short 'i'
      &lt;&gt; metavar &quot;DIRECTORY&quot;
      &lt;&gt; help &quot;Input directory&quot;
    )

pOutputDir :: Parser FilePath
pOutputDir =
  strOption
    ( long &quot;output&quot;
      &lt;&gt; short 'o'
      &lt;&gt; metavar &quot;DIRECTORY&quot;
      &lt;&gt; help &quot;Output directory&quot;
    )

pConvertDir :: Parser Options
pConvertDir =
  ConvertDir &lt;$&gt; pInputDir &lt;*&gt; pOutputDir
</code></pre>
</details>
<hr />
<h4 id="alternative"><a class="header" href="#alternative">Alternative</a></h4>
<p>One thing we forgot about is that each input and output for
<code>ConvertSingle</code> could also potentially use the standard input and output instead.
Up until now, we only offered one option: reading from or writing to a file
by specifying the flags <code>--input</code> and <code>--output</code>.
However, we'd like to make these flags optional, and when they are
not specified, use the alternative standard i/o. We can do that by using
the function <code>optional</code> from <code>Control.Applicative</code>:</p>
<pre><code class="language-hs">optional :: Alternative f =&gt; f a -&gt; f (Maybe a)
</code></pre>
<p><code>optional</code> works on types which implement instances of the
<a href="https://hackage.haskell.org/package/base-4.16.4.0/docs/Control-Applicative.html#t:Alternative"><code>Alternative</code></a> type class:</p>
<pre><code class="language-hs">class Applicative f =&gt; Alternative f where
  (&lt;|&gt;) :: f a -&gt; f a -&gt; f a
  empty :: f a
</code></pre>
<p><code>Alternative</code> looks very similar to the <code>Monoid</code> type class,
but it works on applicative functors. This type class isn't
very common and is mostly used for parsing libraries as far as I know.
It provides us with an interface to combine two <code>Parser</code>s -
if the first one fails to parse, try the other.
It also provides other useful functions such as <code>optional</code>,
which will help us with our case:</p>
<pre><code class="language-hs">pSingleInput :: Parser SingleInput
pSingleInput =
  fromMaybe Stdin &lt;$&gt; optional pInputFile

pSingleOutput :: Parser SingleOutput
pSingleOutput =
  fromMaybe Stdout &lt;$&gt; optional pOutputFile
</code></pre>
<p>Note that with <code>fromMaybe :: a -&gt; Maybe a -&gt; a</code> we can extract
the <code>a</code> out of the <code>Maybe</code> by supplying a value for the <code>Nothing</code> case.</p>
<p>Now we can use these more appropriate functions in <code>pConvertSingle</code> instead:</p>
<pre><code class="language-hs">pConvertSingle :: Parser Options
pConvertSingle =
  ConvertSingle &lt;$&gt; pSingleInput &lt;*&gt; pSingleOutput
</code></pre>
<h4 id="commands-and-subparsers"><a class="header" href="#commands-and-subparsers">Commands and subparsers</a></h4>
<p>We currently have two possible operations in our interface,
convert a single source, or convert a directory. A nice interface for
selecting the right operation would be via commands.
If the user would like to convert a single source, they can use
<code>convert</code>, for a directory, <code>convert-dir</code>.</p>
<p>We can create a parser with commands with the <code>subparser</code> and <code>command</code>
functions:</p>
<pre><code class="language-hs">subparser :: Mod CommandFields a -&gt; Parser a

command :: String -&gt; ParserInfo a -&gt; Mod CommandFields a
</code></pre>
<p><code>subparser</code> takes <em>command modifiers</em> (which can be constructed
with the <code>command</code> function) as input and produces a <code>Parser</code>.
<code>command</code> takes the command name (in our case, &quot;convert&quot; or &quot;convert-dir&quot;)
and a <code>ParserInfo a</code>, and produces a command modifier. As we've seen
before these modifiers have a <code>Monoid</code> instance, and they can be
composed, meaning that we can append multiple commands to serve as alternatives.</p>
<p>A <code>ParserInfo a</code> can be constructed with the <code>info</code> function:</p>
<pre><code class="language-hs">info :: Parser a -&gt; InfoMod a -&gt; ParserInfo a
</code></pre>
<p>This function wraps a <code>Parser</code> with some additional information
such as a helper message, description, and more, so that the program
itself, and each sub-command can print some additional information.</p>
<p>Let's see how to construct a <code>ParserInfo</code>:</p>
<pre><code class="language-hs">pConvertSingleInfo :: ParserInfo Options
pConvertSingleInfo =
  info
    (helper &lt;*&gt; pConvertSingle)
    (progDesc &quot;Convert a single markup source to html&quot;)
</code></pre>
<p>Note that <code>helper</code> adds a helper output screen in case the parser fails.</p>
<p>Let's also build a command:</p>
<pre><code class="language-hs">pConvertSingleCommand :: Mod CommandFields Options
pConvertSingleCommand =
  command &quot;convert&quot; pConvertSingleInfo
</code></pre>
<p>Try creating a <code>Parser Options</code> combining the two options with <code>subparser</code>.</p>
<details><summary>Solution</summary>
<pre><code class="language-hs">pOptions :: Parser Options
pOptions =
  subparser
    ( command
      &quot;convert&quot;
      ( info
        (helper &lt;*&gt; pConvertSingle)
        (progDesc &quot;Convert a single markup source to html&quot;)
      )
      &lt;&gt; command
      &quot;convert-dir&quot;
      ( info
        (helper &lt;*&gt; pConvertDir)
        (progDesc &quot;Convert a directory of markup files to html&quot;)
      )
    )
</code></pre>
</details>
<h4 id="parserinfo"><a class="header" href="#parserinfo">ParserInfo</a></h4>
<p>Since we finished building a parser, we should wrap it up in a <code>ParserInfo</code>
and add some information to it to make it ready to run:</p>
<pre><code class="language-hs">opts :: ParserInfo Options
opts =
  info (helper &lt;*&gt; pOptions)
    ( fullDesc
      &lt;&gt; header &quot;hs-blog-gen - a static blog generator&quot;
      &lt;&gt; progDesc &quot;Convert markup files or directories to html&quot;
    )
</code></pre>
<h3 id="running-a-parser"><a class="header" href="#running-a-parser">Running a parser</a></h3>
<p><code>optparse-applicative</code> provides a non-<code>IO</code> interface to parse arguments,
but the most convenient way to use it is to let it take care of fetching
program arguments, try to parse them, and throw errors and help messages in case
it fails. This can be done with the function <code>execParser :: ParserInfo a -&gt; IO a</code>.</p>
<p>We can place all these options parsing stuff in a new module
and then import it from <code>app/Main.hs</code>. Let's do that.
Here's what we have up until now:</p>
<details><summary>app/OptParse.hs</summary>
<pre><code class="language-hs">-- | Command-line options parsing

module OptParse
  ( Options(..)
  , SingleInput(..)
  , SingleOutput(..)
  , parse
  )
  where

import Data.Maybe (fromMaybe)
import Options.Applicative

------------------------------------------------
-- * Our command-line options model

-- | Model
data Options
  = ConvertSingle SingleInput SingleOutput
  | ConvertDir FilePath FilePath
  deriving Show

-- | A single input source
data SingleInput
  = Stdin
  | InputFile FilePath
  deriving Show

-- | A single output sink
data SingleOutput
  = Stdout
  | OutputFile FilePath
  deriving Show

------------------------------------------------
-- * Parser

-- | Parse command-line options
parse :: IO Options
parse = execParser opts

opts :: ParserInfo Options
opts =
  info (pOptions &lt;**&gt; helper)
    ( fullDesc
      &lt;&gt; header &quot;hs-blog-gen - a static blog generator&quot;
      &lt;&gt; progDesc &quot;Convert markup files or directories to html&quot;
    )

-- | Parser for all options
pOptions :: Parser Options
pOptions =
  subparser
    ( command
      &quot;convert&quot;
      ( info
        (helper &lt;*&gt; pConvertSingle)
        (progDesc &quot;Convert a single markup source to html&quot;)
      )
      &lt;&gt; command
      &quot;convert-dir&quot;
      ( info
        (helper &lt;*&gt; pConvertDir)
        (progDesc &quot;Convert a directory of markup files to html&quot;)
      )
    )

------------------------------------------------
-- * Single source to sink conversion parser

-- | Parser for single source to sink option
pConvertSingle :: Parser Options
pConvertSingle =
  ConvertSingle &lt;$&gt; pSingleInput &lt;*&gt; pSingleOutput

-- | Parser for single input source
pSingleInput :: Parser SingleInput
pSingleInput =
  fromMaybe Stdin &lt;$&gt; optional pInputFile

-- | Parser for single output sink
pSingleOutput :: Parser SingleOutput
pSingleOutput =
  fromMaybe Stdout &lt;$&gt; optional pOutputFile

-- | Input file parser
pInputFile :: Parser SingleInput
pInputFile = fmap InputFile parser
  where
    parser =
      strOption
        ( long &quot;input&quot;
          &lt;&gt; short 'i'
          &lt;&gt; metavar &quot;FILE&quot;
          &lt;&gt; help &quot;Input file&quot;
        )

-- | Output file parser
pOutputFile :: Parser SingleOutput
pOutputFile = OutputFile &lt;$&gt; parser
  where
    parser =
      strOption
        ( long &quot;output&quot;
          &lt;&gt; short 'o'
          &lt;&gt; metavar &quot;FILE&quot;
          &lt;&gt; help &quot;Output file&quot;
        )

------------------------------------------------
-- * Directory conversion parser

pConvertDir :: Parser Options
pConvertDir =
  ConvertDir &lt;$&gt; pInputDir &lt;*&gt; pOutputDir

-- | Parser for input directory
pInputDir :: Parser FilePath
pInputDir =
  strOption
    ( long &quot;input&quot;
      &lt;&gt; short 'i'
      &lt;&gt; metavar &quot;DIRECTORY&quot;
      &lt;&gt; help &quot;Input directory&quot;
    )

-- | Parser for output directory
pOutputDir :: Parser FilePath
pOutputDir =
  strOption
    ( long &quot;output&quot;
      &lt;&gt; short 'o'
      &lt;&gt; metavar &quot;DIRECTORY&quot;
      &lt;&gt; help &quot;Output directory&quot;
    )
</code></pre>
</details>
<h3 id="pattern-matching-on-options"><a class="header" href="#pattern-matching-on-options">Pattern matching on Options</a></h3>
<p>After running the command-line arguments parser, we can pattern match
on our model and call the right functions. Currently, our program
does not expose this kind of API. So let's go to our <code>src/HsBlog.hs</code>
module and change the API. We can delete <code>main</code> from that file and
add two new functions instead:</p>
<pre><code class="language-hs">convertSingle :: Html.Title -&gt; Handle -&gt; Handle -&gt; IO ()

convertDirectory :: FilePath -&gt; FilePath -&gt; IO ()
</code></pre>
<p><a href="https://hackage.haskell.org/package/base-4.16.4.0/docs/System-IO.html#t:Handle"><code>Handle</code></a>
is an I/O abstraction over file system objects, including <code>stdin</code> and <code>stdout</code>.
Before, we used <code>writeFile</code> and <code>getContents</code> - these functions either
get a <code>FilePath</code> to open and work on, or they assume the <code>Handle</code> is the standard I/O.
We can use the explicit versions that take a <code>Handle</code> from <code>System.IO</code> instead:</p>
<pre><code class="language-hs">convertSingle :: Html.Title -&gt; Handle -&gt; Handle -&gt; IO ()
convertSingle title input output = do
  content &lt;- hGetContents input
  hPutStrLn output (process title content)
</code></pre>
<p>We will leave <code>convertDirectory</code> unimplemented for now and implement it in the next chapter.</p>
<p>In <code>app/Main.hs</code>, we will need to pattern match on the <code>Options</code> and
prepare to call the right functions from <code>HsBlog</code>.</p>
<p>Let's look at our full <code>app/Main.hs</code> and <code>src/HsBlog.hs</code>:</p>
<details><summary>app/Main.hs</summary>
<pre><code class="language-hs">-- | Entry point for the hs-blog-gen program

module Main where

import OptParse
import qualified HsBlog

import System.Exit (exitFailure)
import System.Directory (doesFileExist)
import System.IO

main :: IO ()
main = do
  options &lt;- parse
  case options of
    ConvertDir input output -&gt;
      HsBlog.convertDirectory input output

    ConvertSingle input output -&gt; do
      (title, inputHandle) &lt;-
        case input of
          Stdin -&gt;
            pure (&quot;&quot;, stdin)
          InputFile file -&gt;
            (,) file &lt;$&gt; openFile file ReadMode

      outputHandle &lt;-
        case output of
          Stdout -&gt; pure stdout
          OutputFile file -&gt; do
            exists &lt;- doesFileExist file
            shouldOpenFile &lt;-
              if exists
                then confirm
                else pure True
            if shouldOpenFile
              then
                openFile file WriteMode
              else
                exitFailure

      HsBlog.convertSingle title inputHandle outputHandle
      hClose inputHandle
      hClose outputHandle

------------------------------------------------
-- * Utilities

-- | Confirm user action
confirm :: IO Bool
confirm =
  putStrLn &quot;Are you sure? (y/n)&quot; *&gt;
    getLine &gt;&gt;= \answer -&gt;
      case answer of
        &quot;y&quot; -&gt; pure True
        &quot;n&quot; -&gt; pure False
        _ -&gt; putStrLn &quot;Invalid response. use y or n&quot; *&gt;
          confirm
</code></pre>
</details>
<details><summary>src/HsBlog.hs</summary>
<pre><code class="language-hs">-- HsBlog.hs
module HsBlog
  ( convertSingle
  , convertDirectory
  , process
  )
  where

import qualified HsBlog.Markup as Markup
import qualified HsBlog.Html as Html
import HsBlog.Convert (convert)

import System.IO

convertSingle :: Html.Title -&gt; Handle -&gt; Handle -&gt; IO ()
convertSingle title input output = do
  content &lt;- hGetContents input
  hPutStrLn output (process title content)

convertDirectory :: FilePath -&gt; FilePath -&gt; IO ()
convertDirectory = error &quot;Not implemented&quot;

process :: Html.Title -&gt; String -&gt; String
process title = Html.render . convert title . Markup.parse
</code></pre>
</details>
<p>We need to make a few small changes to the <code>.cabal</code> file.</p>
<p>First, we need to add the dependency <code>directory</code> to the <code>executable</code>,
because we use the library <code>System.Directory</code> in <code>Main</code>.</p>
<p>Second, we need to list <code>OptParse</code> in the list of modules in
the <code>executable</code>.</p>
<pre><code class="language-diff"> executable hs-blog-gen
   import: common-settings
   hs-source-dirs: app
   main-is: Main.hs
+  other-modules:
+    OptParse
   build-depends:
       base
+    , directory
     , optparse-applicative
     , hs-blog
   ghc-options:
     -O
</code></pre>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>We've learned about a new fancy library called <code>optparse-applicative</code>
and used it to create a fancier command-line interface in a declarative way.
See the result of running <code>hs-blog-gen --help</code> (or the equivalent
<code>cabal</code>/<code>stack</code> commands we discussed in the last chapter):</p>
<pre><code>hs-blog-gen - a static blog generator

Usage: hs-blog-gen COMMAND
  Convert markup files or directories to html

Available options:
  -h,--help                Show this help text

Available commands:
  convert                  Convert a single markup source to html
  convert-dir              Convert a directory of markup files to html
</code></pre>
<p>Along the way, we've learned two powerful new abstractions, <code>Functor</code>
and <code>Applicative</code>, as well as revisited an abstraction
called <code>Monoid</code>. With this library, we've seen another example
of the usefulness of these abstractions for constructing APIs and EDSLs.</p>
<p>We will continue to meet these abstractions in the rest of the book.</p>
<hr />
<p><strong>Bonus exercise</strong>: Add another flag named <code>--replace</code> to indicate that
if the output file or directory already exists, replacing them is okay.</p>
<hr />
<blockquote>
<p>You can view the git commit of
<a href="https://github.com/soupi/learn-haskell-blog-generator/commit/d0d76aad632fe3abd8701e44db5ba687e0c7ac96">the changes we've made</a>
and the <a href="https://github.com/soupi/learn-haskell-blog-generator/tree/d0d76aad632fe3abd8701e44db5ba687e0c7ac96">code up until now</a>.</p>
</blockquote>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../05-glue/03-project.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="../06-errors_and_files.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../05-glue/03-project.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="../06-errors_and_files.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script>
            window.playground_copyable = true;
        </script>
        <script src="../elasticlunr.min.js" charset="utf-8"></script>
        <script src="../mark.min.js" charset="utf-8"></script>
        <script src="../searcher.js" charset="utf-8"></script>
        <script src="../clipboard.min.js" charset="utf-8"></script>
        <script src="../highlight.js" charset="utf-8"></script>
        <script src="../book.js" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
